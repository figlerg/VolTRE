import os
from typing import Union

import pytest
from antlr4.error.Errors import ParseCancellationException

from match.match import match
from misc.disambiguate import disambiguate
from parse.quickparse import quickparse
from tests.file_helper import all_tre_files
from sample.sample import sample, DurationSamplerMode

from misc.exceptions import UserError, EmptyLanguageError

# check which should fail
# tests = all_tre_files(ignore_files = ['TODO'])

tests = list()

# standard example
tests.append((os.path.join('..','experiments', 'spec_00.tre'), 3, None, False))
tests.append((os.path.join('..','experiments', 'spec_00.tre'), 0, None, False))
tests.append((os.path.join('..','experiments', 'spec_00.tre'), -27, None, True))    # invalid input

tests.append((os.path.join('..','experiments', 'spec_01.tre'), 4, None, False))
tests.append((os.path.join('..','experiments', 'spec_02.tre'), 2, None, False))
tests.append((os.path.join('..','experiments', 'spec_03.tre'), 2, None, True))      # vanilla invalid, domain inf
tests.append((os.path.join('..','experiments', 'spec_03.tre'), 2, 0.5, False))
tests.append((os.path.join('..','experiments', 'spec_04.tre'), 4, None, True))     # vanilla invalid, domain inf
tests.append((os.path.join('..','experiments', 'spec_04.tre'), 6, 27.5, False))
tests.append((os.path.join('..','experiments', 'spec_05.tre'), 1, None, False))
tests.append((os.path.join('..','experiments', 'spec_06.tre'), 6, None, False))


# intersection tests by
tests.append((os.path.join('..','experiments', 'spec_12_intersection.tre'), 3, 1.5, False))
tests.append((os.path.join('..','experiments', 'spec_12_intersection.tre'), 7, 2, False))
tests.append((os.path.join('..','experiments', 'spec_12_intersection.tre'), 5, 2.5, False))
tests.append((os.path.join('..','experiments', 'spec_12_intersection.tre'), 1, 3, False))

# TAKiller with n = 15. This was autogenerated by my script. will take longer
tests.append((os.path.join('..','experiments', 'TAKiller_15_gen.tre'), 3, None, False))
tests.append((os.path.join('..','experiments', 'TAKiller_15_gen.tre'), 5, None, False))



@pytest.mark.parametrize("file_path, n, T, expected_to_fail", tests)
def test_sample_vanilla(file_path, n, T, expected_to_fail):
    """
    Sampling tests. I need to find n and T wherever applicable.
    :param file_path: Path to the .tre file
    :param expected_to_fail: Boolean indicating if the test is expected to fail
    :return:
    """

    # i only input good testcases here
    print(file_path)

    node = quickparse(file_path)
    print(f"Inputs: "
          f"\n\tphi = {node.getText()}"
          f"\n\tn = {n}"
          f"\n\tT = {T} (sampled if None is given)"
          f"\n\texpected to fail : {expected_to_fail}")


    try:

        w = sample(node=node,n=n,T=T,mode=DurationSamplerMode.VANILLA)

        if T:
            assert w.duration == T, "Bad duration from sampler."

        assert match(w,node) > 0, "Sampled outside of the language."

        print(f"Sampled word {w} with duration {w.duration}.")
        failed = False

    except (UserError, EmptyLanguageError) as e:
        print(f"Failed bad test successfully: {e}")
        failed = True

    # todo revisit this, unnecessarily complicated testing method
    assert (failed and expected_to_fail) or (not failed and not expected_to_fail), "Unexpected test result."





